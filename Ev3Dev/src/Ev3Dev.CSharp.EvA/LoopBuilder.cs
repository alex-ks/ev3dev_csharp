using Ev3Dev.CSharp.EvA.AttributeContracts;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Ev3Dev.CSharp.EvA
{
    public static class LoopBuilder
    {
        private class ValuesCache
        {
            public Dictionary<string, bool> BoolCache { get; } = new Dictionary<string, bool>();
            public Dictionary<string, object> GenericCache { get; } = new Dictionary<string, object>();
        }

        /// <summary>
        /// Creates an EventLoop from a model according to `EvA.AttributeContracts`.
        /// </summary>
        /// <param name="model">An object to be parsed.</param>
        /// <param name="loadPropertiesLazily">
        /// Specifies whether the properties should be cached actively at the beginning of a loop iteration,
        /// or lazily on a first getter call. In any case, all the properties will be cached until the next iteration
        /// to guarantee their persistance during a single iteration.
        /// </param>
        /// <param name="allowEndless">Specifies whether the loop can be built without any shutdown events.</param>
        public static EventLoop BuildLoop(
            this object model,
            bool loadPropertiesLazily = true,
            bool allowEndless = false)
        {
            var valuesCache = new ValuesCache();
            var properties = ExtractProperties(model, valuesCache);

            // special case - shutdown events
            var shutdownEvents = ExtractShutdownEvents(model, properties);

            if (!allowEndless && shutdownEvents.Count == 0)
                throw new InvalidOperationException(Resources.NoShutdownEvent);

            // all actions must have different names (no overload)
            var actions = ExtractContents(model, properties)
                                    .TransformActions()
                                    .TransformLoop(model)
                                    .OrderActions()
                                    .ToList();

            Action fillCache = () =>
            {
                foreach (var pair in properties)
                {
                    var name = pair.Key;
                    var property = pair.Value;
                    if (property.Type.TypeHandle == typeof(bool))
                        valuesCache.BoolCache[name] = property.BooleanGetter();
                    else
                        valuesCache.GenericCache[name] = property.GenericGetter();
                }
            };

            Action clearCache = () =>
            {
                valuesCache.BoolCache.Clear();
                valuesCache.GenericCache.Clear();
            };

            var loop = new EventLoop(fillCache, clearCache) { LoadPropertiesLazily = loadPropertiesLazily };

            for (int i = 0; i < actions.Count; ++i)
                loop.RegisterAction(actions[i], i);

            foreach (var shutdownEvent in shutdownEvents)
                loop.RegisterShutdownEvent(shutdownEvent);

            return loop;
        }

        private static Dictionary<string, PropertyWrapper> ExtractProperties(
            object model,
            ValuesCache valuesCache)
        {
            // All properties names must be unique.
            var getters = new Dictionary<string, PropertyWrapper>();

            foreach (var prop in model.GetType().GetProperties())
            {
                // plain getters
                if (prop.PropertyType == typeof(bool))
                    getters.Add(prop.Name, CreateCachingProperty(prop.PropertyType,
                                                                 DelegateGenerator.CreateGetter<bool>(model, prop),
                                                                 valuesCache,
                                                                 prop.Name));
                else
                    getters.Add(prop.Name, CreateCachingProperty(prop.PropertyType,
                                                                 DelegateGenerator.CreateGetter(model, prop),
                                                                 valuesCache,
                                                                 prop.Name));

                // custom getters
                foreach (var extractor in prop.GetCustomAttributes(inherit: true)
                                              .Where(attr => attr is AbstractPropertyExtractor)
                                              .Select(attr => attr as AbstractPropertyExtractor))
                {
                    var (name, customGetter, t) = extractor.ExtractProperty(model, prop);
                    if (getters.ContainsKey(name))
                        throw new InvalidOperationException(
                            string.Format("Name {0} of property generated by {1} is already used",
                                          name,
                                          extractor.GetType().Name));
                    getters.Add(name, CreateCachingProperty(t,
                                                                 customGetter,
                                                                 valuesCache,
                                                                 name));
                }
            }

            return getters;
        }

        private static PropertyWrapper CreateCachingProperty(
            Type type,
            Delegate delegateObj,
            ValuesCache valuesCache,
            string name)
        {
            if (type == typeof(bool))
            {
                var boolGetter = delegateObj as Func<bool>;
                Func<bool> cachedGetter = () =>
                {
                    if (valuesCache.BoolCache.TryGetValue(name, out bool cached))
                        return cached;
                    var value = boolGetter();
                    valuesCache.BoolCache.Add(name, value);
                    return value;
                };
                return new PropertyWrapper(type, cachedGetter);
            }
            else
            {
                var getter = delegateObj as Func<object>;
                Func<object> cachedGetter = () =>
                {
                    if (valuesCache.GenericCache.TryGetValue(name, out object cached))
                        return cached;
                    var value = getter();
                    valuesCache.GenericCache.Add(name, value);
                    return value;
                };
                return new PropertyWrapper(type, cachedGetter);
            }
        }

        private static List<Func<bool>> ExtractShutdownEvents(object model,
                                                              IReadOnlyDictionary<string, PropertyWrapper> properties)
        {
            var shutdownEvents = from prop in model.GetType().GetProperties()
                                 let attribute = prop.GetCustomAttribute<ShutdownEventAttribute>()
                                 where attribute != null
                                 select prop;

            var shutdownEventsGetters = shutdownEvents.Select(prop => properties[prop.Name].BooleanGetter).ToList();

            return shutdownEventsGetters;
        }

        private static ActionContents ExtractContents(object model, IReadOnlyDictionary<string, PropertyWrapper> properties)
        {
            var actions = new Dictionary<string, (Action action, object[] attributes)>();
            var asyncActions = new Dictionary<string, (Func<Task> action, object[] attributes)>();

            var names = new HashSet<string>();

            foreach (var method in model.GetType().GetMethods())
            {
                // reflection attributes are recreated on each GetCustomAttributes call, so we need to be sure we call
                // it only once.
                var attributes = method.GetCustomAttributes(true);
                IActionExtractor extractor;

                try
                {
                    extractor = attributes.Select(attr => attr as IActionExtractor)
                                          .Where(attr => attr != null)
                                          .SingleOrDefault();
                }
                catch (InvalidOperationException)
                {
                    // todo: add to resources
                    throw new InvalidOperationException("Method should have only one action extractor");
                }

                if (extractor == null)
                    continue;

                if (method.ReturnType == typeof(void))
                {
                    var action = extractor.ExtractAction(model, method, properties);

                    if (names.Contains(method.Name))  // todo: add to resources
                        throw new InvalidOperationException("All actions must have different names");

                    actions.Add(method.Name, (action, attributes));
                }
                else if (method.ReturnType == typeof(Task))
                {
                    var action = extractor.ExtractAsyncAction(model, method, properties);

                    if (names.Contains(method.Name))  // todo: add to resources
                        throw new InvalidOperationException("All actions must have different names");

                    asyncActions.Add(method.Name, (action, attributes));
                }
                else
                {
                    throw new InvalidOperationException(string.Format(Resources.InvalidAsyncAction,
                                                                        method.Name));
                }
                names.Add(method.Name);
            }

            return new ActionContents(properties, actions, asyncActions);
        }

        private static ActionContents TransformActions(this ActionContents contents)
        {
            var transformedActions = new Dictionary<string, (Action action, object[] attributes)>();
            var transformedAsyncs = new Dictionary<string, (Func<Task> action, object[] attributes)>();

            foreach (var pair in contents.Actions)
            {
                var transformers = pair.Value.attributes.Select(attr => attr as IActionTransformer)
                                                        .Where(attr => attr != null);

                var transformed = pair.Value.action;

                foreach (var transformer in transformers)
                    transformed = transformer.TransformAction(pair.Key,
                                                              transformed,
                                                              pair.Value.attributes,
                                                              contents.Properties);

                transformedActions.Add(pair.Key, (transformed, pair.Value.attributes));
            }

            foreach (var pair in contents.AsyncActions)
            {
                var transformers = pair.Value.attributes.Select(attr => attr as IActionTransformer)
                                                        .Where(attr => attr != null);

                var transformed = pair.Value.action;

                foreach (var transformer in transformers)
                    transformed = transformer.TransformAsyncAction(pair.Key,
                                                                   transformed,
                                                                   pair.Value.attributes,
                                                                   contents.Properties);

                transformedAsyncs.Add(pair.Key, (transformed, pair.Value.attributes));
            }

            return new ActionContents(contents.Properties, transformedActions, transformedAsyncs);
        }

        private static LoopContents TransformLoop(this ActionContents contents, object model)
        {
            var transformedActions = new Dictionary<string, (Action action, object[] attributes)>();
            var transformedAsyncs = new Dictionary<string, (Func<Task> action, object[] attributes)>();

            var attributes = model.GetType().GetCustomAttributes(true);

            var transformers = attributes.Select(attr => attr as ILoopTransformer)
                                         .Where(attr => attr != null);

            foreach (var transformer in transformers)
            {
                contents = transformer.TransformLoop(contents, attributes);
            }

            return contents.ToLoopContents(attributes);
        }

        private static IEnumerable<Action> OrderActions(this LoopContents contents)
        {
            var sorters = contents.ModelAttributes.Select(attr => attr as IActionSorter)
                                                  .Where(attr => attr != null);
            return sorters.Aggregate(contents.Actions, (acts, sorter) => sorter.SortActions(acts))
                          .Select(t => t.action);
        }
    }
}
